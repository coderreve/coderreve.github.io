<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.45" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://syriansoldier.github.io/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html"><meta property="og:site_name" content="苏灿的博客"><meta property="og:title" content="算法刷题"><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><link rel="stylesheet" href="//at.alicdn.com/t/font_2410206_mfj6e1vbwo.css"><link rel="manifest" href="/manifest.webmanifest" crossorigin="use-credentials"><meta name="theme-color" content="#46bd87"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"><title>算法刷题 | 苏灿的博客</title><meta name="description" content="苏察哈尔灿的博客">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.b732f1d8.css">
    <link rel="modulepreload" href="/assets/app.ebc51866.js"><link rel="modulepreload" href="/assets/算法刷题.html.9702947b.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/算法刷题.html.6f122698.js"><link rel="prefetch" href="/assets/index.html.310999fa.js"><link rel="prefetch" href="/assets/数据结构与算法.html.d9f94832.js"><link rel="prefetch" href="/assets/设计模式.html.40b27c48.js"><link rel="prefetch" href="/assets/grammer.html.9776c235.js"><link rel="prefetch" href="/assets/2023-且将新火试新茶_诗酒趁年华.html.7d1edac5.js"><link rel="prefetch" href="/assets/面试八股文.html.c6d97d3f.js"><link rel="prefetch" href="/assets/async-await.html.a71cd1ba.js"><link rel="prefetch" href="/assets/Promise源码.html.79845a04.js"><link rel="prefetch" href="/assets/typescript.html.6e494c6d.js"><link rel="prefetch" href="/assets/拖拽.html.2419e949.js"><link rel="prefetch" href="/assets/计算机网络.html.a52271a4.js"><link rel="prefetch" href="/assets/性能优化.html.fc023bfd.js"><link rel="prefetch" href="/assets/react基础语法.html.8304b2b1.js"><link rel="prefetch" href="/assets/vue3语法.html.57091ca7.js"><link rel="prefetch" href="/assets/vuex.html.ff5571e6.js"><link rel="prefetch" href="/assets/声明式渲染进阶.html.223d0187.js"><link rel="prefetch" href="/assets/自动注册全局组件.html.25b3ff5d.js"><link rel="prefetch" href="/assets/spliteChunks.html.4601d8f7.js"><link rel="prefetch" href="/assets/404.html.8ff2acde.js"><link rel="prefetch" href="/assets/index.html.1cad6853.js"><link rel="prefetch" href="/assets/index.html.5dc7b835.js"><link rel="prefetch" href="/assets/index.html.35625e88.js"><link rel="prefetch" href="/assets/index.html.b52a2a08.js"><link rel="prefetch" href="/assets/index.html.3ae25e5d.js"><link rel="prefetch" href="/assets/index.html.7895b365.js"><link rel="prefetch" href="/assets/index.html.f6fb7498.js"><link rel="prefetch" href="/assets/index.html.badae06b.js"><link rel="prefetch" href="/assets/index.html.89e51423.js"><link rel="prefetch" href="/assets/index.html.d4d323a2.js"><link rel="prefetch" href="/assets/index.html.cd8e9ea7.js"><link rel="prefetch" href="/assets/index.html.3210836e.js"><link rel="prefetch" href="/assets/index.html.4ba5933f.js"><link rel="prefetch" href="/assets/index.html.4df672f1.js"><link rel="prefetch" href="/assets/index.html.da97b75e.js"><link rel="prefetch" href="/assets/index.html.d0e41017.js"><link rel="prefetch" href="/assets/index.html.5eb76348.js"><link rel="prefetch" href="/assets/index.html.3ab1800f.js"><link rel="prefetch" href="/assets/数据结构与算法.html.15bb9d6c.js"><link rel="prefetch" href="/assets/设计模式.html.76ff234c.js"><link rel="prefetch" href="/assets/grammer.html.d33414c5.js"><link rel="prefetch" href="/assets/2023-且将新火试新茶_诗酒趁年华.html.f136324a.js"><link rel="prefetch" href="/assets/面试八股文.html.b2903274.js"><link rel="prefetch" href="/assets/async-await.html.85b5b227.js"><link rel="prefetch" href="/assets/Promise源码.html.a81dbf89.js"><link rel="prefetch" href="/assets/typescript.html.2d4d177b.js"><link rel="prefetch" href="/assets/拖拽.html.3f4a5dcc.js"><link rel="prefetch" href="/assets/计算机网络.html.b5f82ad1.js"><link rel="prefetch" href="/assets/性能优化.html.9c6d5cca.js"><link rel="prefetch" href="/assets/react基础语法.html.b7507e0b.js"><link rel="prefetch" href="/assets/vue3语法.html.f0878dde.js"><link rel="prefetch" href="/assets/vuex.html.9c5be4a2.js"><link rel="prefetch" href="/assets/声明式渲染进阶.html.191eb584.js"><link rel="prefetch" href="/assets/自动注册全局组件.html.495d943a.js"><link rel="prefetch" href="/assets/spliteChunks.html.6295a76c.js"><link rel="prefetch" href="/assets/404.html.02198cc7.js"><link rel="prefetch" href="/assets/index.html.9d08ced7.js"><link rel="prefetch" href="/assets/index.html.3deb94dd.js"><link rel="prefetch" href="/assets/index.html.779edf93.js"><link rel="prefetch" href="/assets/index.html.a0f83adc.js"><link rel="prefetch" href="/assets/index.html.5b3dfc1f.js"><link rel="prefetch" href="/assets/index.html.610d9368.js"><link rel="prefetch" href="/assets/index.html.faa58f47.js"><link rel="prefetch" href="/assets/index.html.b941680d.js"><link rel="prefetch" href="/assets/index.html.1f681046.js"><link rel="prefetch" href="/assets/index.html.d44c507b.js"><link rel="prefetch" href="/assets/index.html.212ed33a.js"><link rel="prefetch" href="/assets/index.html.81e79039.js"><link rel="prefetch" href="/assets/index.html.6783f1b8.js"><link rel="prefetch" href="/assets/index.html.30d3decb.js"><link rel="prefetch" href="/assets/index.html.1708e449.js"><link rel="prefetch" href="/assets/index.html.f28fcb1f.js"><link rel="prefetch" href="/assets/index.html.3e4948b8.js"><link rel="prefetch" href="/assets/404.dfbd2fc7.js"><link rel="prefetch" href="/assets/Layout.514b6ccb.js"><link rel="prefetch" href="/assets/Slide.baff26b0.js"><link rel="prefetch" href="/assets/Blog.9daeead8.js"><link rel="prefetch" href="/assets/auto.esm.15d52109.js"><link rel="prefetch" href="/assets/index.1842ee54.js"><link rel="prefetch" href="/assets/mermaid.esm.min.95aabeb7.js"><link rel="prefetch" href="/assets/highlight.esm.d982e650.js"><link rel="prefetch" href="/assets/markdown.esm.832a189d.js"><link rel="prefetch" href="/assets/math.esm.a3f84b6f.js"><link rel="prefetch" href="/assets/notes.esm.3c361cb7.js"><link rel="prefetch" href="/assets/reveal.esm.b96f05d8.js"><link rel="prefetch" href="/assets/search.esm.80da4a02.js"><link rel="prefetch" href="/assets/zoom.esm.8514a202.js"><link rel="prefetch" href="/assets/photoswipe.esm.92018b73.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc sidebar-open"><!--[--><!--[--><header class="navbar"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><a href="/" class="home-link"><img class="logo" src="/logo.svg" alt="苏灿的博客"><!----><span class="site-name hide-in-pad">苏灿的博客</span><!--[--><!----><!--]--></a><nav class="nav-links" style=""><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="React"><span class="title"><i class="icon iconfont icon-edit"></i>React</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/react/react%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html" class="nav-link" aria-label="React18+Redux/RTK语法"><i class="icon iconfont icon-edit"></i>React18+Redux/RTK语法<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="Vue"><span class="title"><i class="icon iconfont icon-edit"></i>Vue</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/vue/vue3%E8%AF%AD%E6%B3%95.html" class="nav-link" aria-label="Vue3语法"><i class="icon iconfont icon-edit"></i>Vue3语法<!----></a></li><li class="dropdown-item"><a href="/vue/vuex.html" class="nav-link" aria-label="Vuex"><i class="icon iconfont icon-edit"></i>Vuex<!----></a></li><li class="dropdown-item"><a href="/vue/%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%B8%B2%E6%9F%93%E8%BF%9B%E9%98%B6.html" class="nav-link" aria-label="Vue中的Render函数与Jsx"><i class="icon iconfont icon-edit"></i>Vue中的Render函数与Jsx<!----></a></li><li class="dropdown-item"><a href="/vue/%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%86%8C%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6.html" class="nav-link" aria-label="自动注册全局组件"><i class="icon iconfont icon-edit"></i>自动注册全局组件<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="Javascript"><span class="title"><i class="icon iconfont icon-edit"></i>Javascript</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/js/async-await.html" class="nav-link" aria-label="async/await原理"><i class="icon iconfont icon-edit"></i>async/await原理<!----></a></li><li class="dropdown-item"><a href="/js/Promise%E6%BA%90%E7%A0%81.html" class="nav-link" aria-label="Promise源码"><i class="icon iconfont icon-edit"></i>Promise源码<!----></a></li><li class="dropdown-item"><a href="/js/%E6%8B%96%E6%8B%BD.html" class="nav-link" aria-label="drag&amp;dropApi"><i class="icon iconfont icon-edit"></i>drag&amp;dropApi<!----></a></li><li class="dropdown-item"><a href="/js/typescript.html" class="nav-link" aria-label="typescript"><i class="icon iconfont icon-edit"></i>typescript<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="数据结构与算法"><span class="title"><i class="icon iconfont icon-edit"></i>数据结构与算法</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html" class="nav-link" aria-label="数据结构与算法"><i class="icon iconfont icon-edit"></i>数据结构与算法<!----></a></li><li class="dropdown-item"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html" class="router-link-active router-link-exact-active nav-link active" aria-label="算法刷题"><i class="icon iconfont icon-edit"></i>算法刷题<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="计算机网络"><span class="title"><i class="icon iconfont icon-edit"></i>计算机网络</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html" class="nav-link" aria-label="计算机网络"><i class="icon iconfont icon-edit"></i>计算机网络<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="性能优化"><span class="title"><i class="icon iconfont icon-edit"></i>性能优化</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/performance/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html" class="nav-link" aria-label="前端性能优化"><i class="icon iconfont icon-edit"></i>前端性能优化<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="webpack"><span class="title"><i class="icon iconfont icon-edit"></i>webpack</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/webpack/spliteChunks.html" class="nav-link" aria-label="代码分割"><i class="icon iconfont icon-edit"></i>代码分割<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="设计模式"><span class="title"><i class="icon iconfont icon-edit"></i>设计模式</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/design-pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" class="nav-link" aria-label="设计模式"><i class="icon iconfont icon-edit"></i>设计模式<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="英语"><span class="title"><i class="icon iconfont icon-edit"></i>英语</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/english/grammer.html" class="nav-link" aria-label="英语语法"><i class="icon iconfont icon-edit"></i>英语语法<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="面试八股文"><span class="title"><i class="icon iconfont icon-edit"></i>面试八股文</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/interview/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87.html" class="nav-link" aria-label="面试八股文"><i class="icon iconfont icon-edit"></i>面试八股文<!----></a></li></ul></button></div></div></nav><div class="nav-actions-wrapper"><!--[--><!----><!--]--><div class="nav-item"><!----></div><!----><div class="nav-item hide-in-mobile"><button class="outlook-button" tabindex="-1" ariahidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button><!--[--><!----><!--]--></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><i class="icon iconfont icon-edit"></i><span class="title">React</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><i class="icon iconfont icon-edit"></i><span class="title">Vue</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><i class="icon iconfont icon-edit"></i><span class="title">Javascript</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><i class="icon iconfont icon-edit"></i><span class="title">数据结构与算法</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html" class="nav-link sidebar-link sidebar-page" aria-label="数据结构与算法"><i class="icon iconfont icon-edit"></i>数据结构与算法<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="算法刷题"><i class="icon iconfont icon-edit"></i>算法刷题<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#两数之和" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="两数之和"><!---->两数之和<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#有效的括号" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="有效的括号"><!---->有效的括号<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#合并两个有序链表" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="合并两个有序链表"><!---->合并两个有序链表<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#爬楼梯" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="爬楼梯"><!---->爬楼梯<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#二叉树的中序遍历" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="二叉树的中序遍历"><!---->二叉树的中序遍历<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#对称二叉树" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="对称二叉树"><!---->对称二叉树<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#二叉树的最大深度" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="二叉树的最大深度"><!---->二叉树的最大深度<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#买卖股票的最佳时机" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="买卖股票的最佳时机"><!---->买卖股票的最佳时机<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#只出现一次的数字" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="只出现一次的数字"><!---->只出现一次的数字<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#环形链表" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="环形链表"><!---->环形链表<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#相交链表" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="相交链表"><!---->相交链表<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#反转链表" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="反转链表"><!---->反转链表<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#回文链表" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="回文链表"><!---->回文链表<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#移动零" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="移动零"><!---->移动零<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#比特位计数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="比特位计数"><!---->比特位计数<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#找到所有数组中消失的数字" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="找到所有数组中消失的数字"><!---->找到所有数组中消失的数字<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#二叉树的直径" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="二叉树的直径"><!---->二叉树的直径<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#合并二叉树" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="合并二叉树"><!---->合并二叉树<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#回溯-子集" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="回溯 -- 子集"><!---->回溯 -- 子集<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#回溯-全排列" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="回溯 -- 全排列"><!---->回溯 -- 全排列<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#回溯-括号生成" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="回溯 -- 括号生成"><!---->回溯 -- 括号生成<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#分治-从前序与中序遍历序列构造二叉树" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="分治 -- 从前序与中序遍历序列构造二叉树"><!---->分治 -- 从前序与中序遍历序列构造二叉树<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#分治-从后序与中序遍历序列构造二叉树" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="分治 -- 从后序与中序遍历序列构造二叉树"><!---->分治 -- 从后序与中序遍历序列构造二叉树<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#分治-数组中的第k个最大元素" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="分治 -- 数组中的第K个最大元素"><!---->分治 -- 数组中的第K个最大元素<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#贪心-盛最多水的容器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="贪心 -- 盛最多水的容器"><!---->贪心 -- 盛最多水的容器<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#贪心-跳跃游戏" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="贪心 -- 跳跃游戏"><!---->贪心 -- 跳跃游戏<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><i class="icon iconfont icon-edit"></i><span class="title">计算机网络</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><i class="icon iconfont icon-edit"></i><span class="title">性能优化</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><i class="icon iconfont icon-edit"></i><span class="title">webpack</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><i class="icon iconfont icon-edit"></i><span class="title">设计模式</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><i class="icon iconfont icon-edit"></i><span class="title">英语</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><i class="icon iconfont icon-edit"></i><span class="title">面试八股文</span><span class="arrow right"></span></button><!----></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->算法刷题</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="author-item" href="https://syriansoldier.github.io/" target="_blank" rel="noopener noreferrer">苏察哈尔灿</a></span><span property="author" content="苏察哈尔灿"></span></span><!----><!----><!----><!----><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 30 分钟</span><meta property="timeRequired" content="PT30M"></span></div><hr></div><div class="toc-place-holder"><aside id="toc-list"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#两数之和" class="router-link-active router-link-exact-active toc-link level2">两数之和</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#有效的括号" class="router-link-active router-link-exact-active toc-link level2">有效的括号</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#合并两个有序链表" class="router-link-active router-link-exact-active toc-link level2">合并两个有序链表</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#爬楼梯" class="router-link-active router-link-exact-active toc-link level2">爬楼梯</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#二叉树的中序遍历" class="router-link-active router-link-exact-active toc-link level2">二叉树的中序遍历</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#对称二叉树" class="router-link-active router-link-exact-active toc-link level2">对称二叉树</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#二叉树的最大深度" class="router-link-active router-link-exact-active toc-link level2">二叉树的最大深度</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#买卖股票的最佳时机" class="router-link-active router-link-exact-active toc-link level2">买卖股票的最佳时机</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#只出现一次的数字" class="router-link-active router-link-exact-active toc-link level2">只出现一次的数字</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#环形链表" class="router-link-active router-link-exact-active toc-link level2">环形链表</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#相交链表" class="router-link-active router-link-exact-active toc-link level2">相交链表</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#反转链表" class="router-link-active router-link-exact-active toc-link level2">反转链表</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#回文链表" class="router-link-active router-link-exact-active toc-link level2">回文链表</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#移动零" class="router-link-active router-link-exact-active toc-link level2">移动零</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#比特位计数" class="router-link-active router-link-exact-active toc-link level2">比特位计数</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#找到所有数组中消失的数字" class="router-link-active router-link-exact-active toc-link level2">找到所有数组中消失的数字</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#二叉树的直径" class="router-link-active router-link-exact-active toc-link level2">二叉树的直径</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#合并二叉树" class="router-link-active router-link-exact-active toc-link level2">合并二叉树</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#回溯-子集" class="router-link-active router-link-exact-active toc-link level2">回溯 -- 子集</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#回溯-全排列" class="router-link-active router-link-exact-active toc-link level2">回溯 -- 全排列</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#回溯-括号生成" class="router-link-active router-link-exact-active toc-link level2">回溯 -- 括号生成</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#分治-从前序与中序遍历序列构造二叉树" class="router-link-active router-link-exact-active toc-link level2">分治 -- 从前序与中序遍历序列构造二叉树</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#分治-从后序与中序遍历序列构造二叉树" class="router-link-active router-link-exact-active toc-link level2">分治 -- 从后序与中序遍历序列构造二叉树</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#分治-数组中的第k个最大元素" class="router-link-active router-link-exact-active toc-link level2">分治 -- 数组中的第K个最大元素</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#贪心-盛最多水的容器" class="router-link-active router-link-exact-active toc-link level2">贪心 -- 盛最多水的容器</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/algorithm/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98.html#贪心-跳跃游戏" class="router-link-active router-link-exact-active toc-link level2">贪心 -- 跳跃游戏</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><!--[--><h1 id="算法刷题" tabindex="-1"><a class="header-anchor" href="#算法刷题" aria-hidden="true">#</a> 算法刷题</h1><h2 id="两数之和" tabindex="-1"><a class="header-anchor" href="#两数之和" aria-hidden="true">#</a> 两数之和</h2><blockquote><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 **和为目标值 **<em>target</em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p></blockquote><blockquote><p><strong>示例 1：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 思路: </span>
<span class="token comment">// 记录当前数字的另一半是谁</span>
<span class="token comment">// 检测当前数字是否是别人的另一半</span>

<span class="token keyword">var</span> <span class="token function-variable function">twoSum</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums<span class="token punctuation">,</span> target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 记录当前数字的下标, 和另一半的值</span>
    <span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> 

    <span class="token comment">// 检查当前数字是否存在于map中</span>
    <span class="token keyword">const</span> <span class="token function-variable function">check</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">nums<span class="token punctuation">,</span> numIdx</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> target <span class="token operator">=</span> nums<span class="token punctuation">[</span>numIdx<span class="token punctuation">]</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> map<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">===</span> map<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token punctuation">[</span>i<span class="token punctuation">,</span>numIdx<span class="token punctuation">]</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>

    
    map<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> target <span class="token operator">-</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 检查当前数字的另一半是否存在</span>
        <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">check</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">)</span>
        map<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> result
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="有效的括号" tabindex="-1"><a class="header-anchor" href="#有效的括号" aria-hidden="true">#</a> 有效的括号</h2><blockquote><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol></blockquote><blockquote><p><strong>示例 ：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入：s = &quot;()[]{}&quot;
输出：true
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p><strong>思考过程：</strong></p><ol><li>首先对 “左括号必须以正确的顺序闭合” 这句话产生了疑问。 这句话的意思是 “左括号右边必须是右括号”的意思吗？ ( { [ } ] ) 这样的括号算是有效的括号吗？</li><li>通过百度， ( { [ } ] ) 这种形式不算是有效的括号。 他的意思是 可以是 &#39;( { [ ] } )&#39; 或者 &#39;[ { ( ) } ]&#39;这种对称结构, 但不能是 &#39;( { [ } ] )&#39; 这种交叉结构</li><li>接下来就很简单了，利用栈保存左括号，遇到右括号就弹出栈看是否匹配。 当遍历完毕后如果栈长度为0则为有效的括号</li></ol><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">isValid</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">s</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
   <span class="token keyword">let</span> right <span class="token operator">=</span> <span class="token string">&#39;&#39;</span> <span class="token comment">//记录当前栈弹出的右括号</span>
   <span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token punctuation">{</span>
     <span class="token string-property property">&#39;(&#39;</span><span class="token operator">:</span><span class="token string">&#39;)&#39;</span><span class="token punctuation">,</span>
     <span class="token string-property property">&#39;[&#39;</span><span class="token operator">:</span><span class="token string">&#39;]&#39;</span><span class="token punctuation">,</span>
     <span class="token string-property property">&#39;{&#39;</span><span class="token operator">:</span><span class="token string">&#39;}&#39;</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">const</span> lefts <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span> <span class="token comment">// 取出所有的左括号</span>
   
   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token comment">// 如果是左括号加到栈中</span>
     <span class="token keyword">if</span><span class="token punctuation">(</span>lefts<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
     <span class="token comment">// 如果是右括号, 弹出元素看是否匹配</span>
     <span class="token keyword">else</span> <span class="token punctuation">{</span>
       right <span class="token operator">=</span> map<span class="token punctuation">[</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>right <span class="token operator">!==</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
         <span class="token keyword">return</span> <span class="token boolean">false</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
  
  <span class="token keyword">return</span> stack<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>**总结: **</p><p>栈可以验证对称结构</p><h2 id="合并两个有序链表" tabindex="-1"><a class="header-anchor" href="#合并两个有序链表" aria-hidden="true">#</a> 合并两个有序链表</h2><blockquote><p>思考: 两个指针用于遍历两个链表. 创建一个新链表. 再来一个节点用于记录新链表的尾巴位置, 用于添加元素</p></blockquote><blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>输入：l1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> l2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
输出：<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>

输入：l1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> l2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
输出：<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) <span class="token punctuation">{</span>
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * <span class="token punctuation">}</span>
 */</span>
<span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>ListNode<span class="token punctuation">}</span></span> <span class="token parameter">list1</span>
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>ListNode<span class="token punctuation">}</span></span> <span class="token parameter">list2</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>ListNode<span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">mergeTwoLists</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">list1<span class="token punctuation">,</span> list2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
    <span class="token keyword">if</span><span class="token punctuation">(</span>list1 <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> list2
    <span class="token punctuation">}</span> 
    
    <span class="token keyword">if</span><span class="token punctuation">(</span>list2 <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> list1
    <span class="token punctuation">}</span>
    <span class="token comment">// 新链表的头部</span>
    <span class="token comment">// 新链表的尾部</span>
    <span class="token keyword">let</span> head <span class="token operator">=</span> tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span> 

   
    <span class="token keyword">while</span><span class="token punctuation">(</span>list1 <span class="token operator">&amp;&amp;</span> list2<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>list1<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> list2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>
            tail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>list1<span class="token punctuation">.</span>val<span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span>
            list1 <span class="token operator">=</span> list1<span class="token punctuation">.</span>next

        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            tail<span class="token punctuation">.</span>next  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>list2<span class="token punctuation">.</span>val<span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span> 
            list2 <span class="token operator">=</span> list2<span class="token punctuation">.</span>next
        <span class="token punctuation">}</span>
        
        tail <span class="token operator">=</span> tail<span class="token punctuation">.</span>next 
    <span class="token punctuation">}</span> 

    tail<span class="token punctuation">.</span>next <span class="token operator">=</span> list1 <span class="token operator">||</span> list2

    <span class="token keyword">return</span> head<span class="token punctuation">.</span>next
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>总结</strong></p><p>代码思路并不难, 但是有个细节卡了我半个小时</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>  <span class="token keyword">while</span><span class="token punctuation">(</span>list1 <span class="token operator">&amp;&amp;</span> list2<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">}</span> 这段 代码我一开始写成了
  <span class="token keyword">while</span><span class="token punctuation">(</span>list1<span class="token punctuation">.</span>next <span class="token operator">&amp;&amp;</span> list2<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">}</span> 导致拿不到最后一个元素   
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>于是要明确遍历链表时候, 什么时候 + .next:</p><p>循环体内用到最后一个元素了, 则不能加.next</p><h2 id="爬楼梯" tabindex="-1"><a class="header-anchor" href="#爬楼梯" aria-hidden="true">#</a> 爬楼梯</h2><blockquote><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p></blockquote><blockquote><p>思考 :</p><ol><li>直觉告诉我是递归, 然后我列出了递龟式</li></ol><p>$ f(n) = { ^{ f(n-1) + 1 , {n &gt; 1} } _{1, {n = 1}} $</p><p>假设f(n)是求n个台阶的方法, 那么就应该等于 f(n -1) + 1种. 至于1个台阶, 就一种走法</p><p>​</p><p>然后写出了函数.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">climbStairs</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span>
    <span class="token keyword">return</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个函数得出了期望外的结果, 我想不出来为什么错了</p><p>经过查询我搞明白了我的问题:</p><p>f(n) 不等于 f(n - 1) + 1, f(n)代表的是n个阶梯会出现的方法数, 少一个阶梯方法数并不一定减1, 可能不变</p><p>​</p><ol start="2"><li><p>如果将走楼梯用可视化的方式抽象思考一想, 感觉像一棵带权的二叉树. 从根节点开始, 每次都有两个子节点.</p><p>那么问题可以被抽象为: &quot;已知有一棵带权的二叉树, 左节点的路径权重为1, 右节点的权重为2, 每个路径的权重和为n, 求有多少条路径?&quot;</p><p>但是我不会解这道题.....</p></li></ol></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// I will use dynamic programming to answer this question.  </span>
<span class="token keyword">var</span> <span class="token function-variable function">climbStairs</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">2</span>

  <span class="token comment">//  An array of dynamic programming, its default value is count of way that move to first step and second step.</span>
  <span class="token keyword">const</span> opt <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    opt<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> opt<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> opt<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
 
  <span class="token keyword">return</span> opt<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>总结:</strong></p><ol><li>递推式为什么是f(n) = f(n-1)+f(n-2)</li></ol><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>由于题目要求只能迈一阶或者两阶
所以要想达到只有两种可能性从n<span class="token operator">-</span><span class="token number">1</span>点迈一步到终点<span class="token punctuation">,</span> 或者从n<span class="token operator">-</span><span class="token number">2</span>点迈两步到达终点

假设从起点到 n<span class="token operator">-</span><span class="token number">1</span>点有 <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>种方案<span class="token punctuation">,</span> <span class="token function">那么从起点点到终点就会有f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">1</span>种方案<span class="token punctuation">.</span>
因为n<span class="token operator">-</span><span class="token number">1</span>点到终点只有一种方案<span class="token punctuation">,</span> 从起点到n<span class="token operator">-</span><span class="token number">1</span><span class="token function">点的每种方案和最后一种方案结合会形成新的f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span> <span class="token number">1</span>种方案

<span class="token literal-property property">同理</span><span class="token operator">:</span> 从n<span class="token operator">-</span><span class="token number">2</span>走一步到终点只有一种方案<span class="token punctuation">.</span> 注意这里说的是从n<span class="token operator">-</span><span class="token number">2</span>直达到终点只有一种方案<span class="token punctuation">,</span> 我们只考虑直达的
方案<span class="token punctuation">.</span> 那么从起点到n<span class="token operator">-</span><span class="token number">2</span>点的每种方案会和n<span class="token operator">-</span><span class="token number">2</span><span class="token function">直达终点形成新的f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1</span>种方案

<span class="token literal-property property">还有一点要注意的是</span><span class="token operator">:</span> <span class="token function">上述和新形成的f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token function">种方案和新形成的f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>种方案是完全不同的
<span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>是和n<span class="token operator">-</span><span class="token number">1</span>点 <span class="token operator">--</span><span class="token operator">&gt;</span>终点集合形成的<span class="token punctuation">,</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>是和n<span class="token operator">-</span><span class="token number">2</span> <span class="token operator">--</span><span class="token operator">&gt;</span> 终点结合形成的<span class="token punctuation">,</span> 他们每一种方案都不同

说完了这些<span class="token punctuation">,</span> <span class="token literal-property property">再来看看问题咋解把</span><span class="token operator">:</span>
<span class="token literal-property property">根据题意</span><span class="token operator">:</span>
<span class="token number">1.</span> 因为一次只能走一步或者两步<span class="token punctuation">,</span> 所以一定会经过n<span class="token operator">-</span><span class="token number">1</span>和n<span class="token operator">-</span><span class="token number">2</span>点其中的一个<span class="token punctuation">.</span>
<span class="token number">2.</span> 从起点到终点的路径数等于<span class="token string">&quot;从起点经过n-1点直达终点的路径数&quot;</span>和<span class="token string">&quot;从起点经过n-2点直达终点的路径数&quot;</span>
<span class="token number">3.</span> 又因为经过n<span class="token operator">-</span><span class="token number">1</span><span class="token function">直达终点的路径数为f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 直达n<span class="token operator">-</span><span class="token number">2</span><span class="token function">点直达终点为f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>个<span class="token punctuation">,</span> 其中并没有重叠的路线<span class="token punctuation">.</span>
所以
<span class="token function">fn</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="二叉树的中序遍历" tabindex="-1"><a class="header-anchor" href="#二叉树的中序遍历" aria-hidden="true">#</a> 二叉树的中序遍历</h2><blockquote><p>给定一个二叉树的根节点 <code>root</code> ，返回 它的 中序遍历 。</p></blockquote><blockquote><p>思路:</p><ol><li><p>递归版</p><blockquote><p>从根节点先处理做深度优先遍历, 先向左深入递归, 再处理左节点, 再向右深度遍历</p></blockquote></li><li><p>非递归版</p><blockquote><p>可以用栈记录从根节点到最左节点的遍历顺序</p><p>弹出节点后处理该节点</p><p>处理完该节点后处理该节点的右节点</p><p>处理右节点的流程是:</p><p>深入所有左节点并加到栈中</p></blockquote></li></ol></blockquote><p><strong>递归版</strong></p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">inorderTraversal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span>result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>result<span class="token punctuation">)</span>
        result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>result<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>非递归, 栈版</strong></p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">inorderTraversal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token comment">// 虽然是从root循环, 但是这是循环, 就要考虑什么是要循环的内容</span>
    <span class="token comment">// 1.给定一个X节点, 将X节点所有左节点加入栈中</span>
    <span class="token comment">// 2. 弹出顶栈帧, 将其指针指向右节点做循环处理</span>
    <span class="token comment">// 3. 在遍历过程中指针的指向: </span>
    <span class="token comment">//    1. 左子节点添加过程中的左子节点 2. 在处理完节点后循环体的最后指针指向待处理的右节点. 右节点的情况可能为null,也可能实际存在.</span>
    

    <span class="token comment">// 按照流程控制, 最后一个遍历的节点为树的最右节点, 出循环的时候指针指向null</span>
    <span class="token comment">// 两个条件都满足时候, 就可以直接循环</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length <span class="token operator">||</span> root <span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">while</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">{</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        root <span class="token operator">=</span> root<span class="token punctuation">.</span>left
      <span class="token punctuation">}</span>
      
      root <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 如果进循环的时候是子树的根节点, 则弹出的是子树的最左节点</span>
                         <span class="token comment">// 如果进循环的时候是右节点并且为null, 弹出的是父节点</span>
      result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> 
      root <span class="token operator">=</span> root<span class="token punctuation">.</span>right <span class="token comment">// 如果进循环的是是子树的根节点, 保存的是右节点</span>
                        <span class="token comment">// 如果进循环的时候是右节点并且为null, 保存的是右节点的右子树</span>
    <span class="token punctuation">}</span>
  
  <span class="token keyword">return</span> result
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="对称二叉树" tabindex="-1"><a class="header-anchor" href="#对称二叉树" aria-hidden="true">#</a> 对称二叉树</h2><blockquote><p>思路: 对左右子树分别递归, 递归后比较左子树的最左系节点和右子树的最左节点, 以及左子树的最右节点和右子树的的最左节点是否相等, 然后向上返回</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) <span class="token punctuation">{</span>
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * <span class="token punctuation">}</span>
 */</span>
<span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span> <span class="token parameter">root</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>boolean<span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">const</span> <span class="token function-variable function">dfs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span>right</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>left<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>val <span class="token operator">!==</span> right<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>left<span class="token punctuation">,</span>right<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">dfs</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>right<span class="token punctuation">,</span>right<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> <span class="token function-variable function">isSymmetric</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="二叉树的最大深度" tabindex="-1"><a class="header-anchor" href="#二叉树的最大深度" aria-hidden="true">#</a> 二叉树的最大深度</h2><blockquote><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p></blockquote><p><strong>示例:</strong></p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>    <span class="token number">3</span>
   <span class="token operator">/</span> \
  <span class="token number">9</span>  <span class="token number">20</span>
    <span class="token operator">/</span>  \
   <span class="token number">15</span>   <span class="token number">7</span>
返回它的最大深度 <span class="token number">3</span> 。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>思考:</p><ol><li>为了解决这个问题, 需要给左右子树要信息, 这个信息是左右子树的深度. 有了左右子树的深度之后就可以求max + 1则为root的最大深度, 根据这个分析就可以列出递推式: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">(</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">(</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">T(n) = max(T(left) , T(right)) + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li><li>也可以从递归的流程来思考, 二叉树dfs的本质是, 递归最后两个节点单独返回信息给父节点加工, 父节点和对应的兄弟节点再执行这个流程, 一直到root. 故而边缘case是为root不存在时候返回0</li></ol></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">maxDepth</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span>

  <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="买卖股票的最佳时机" tabindex="-1"><a class="header-anchor" href="#买卖股票的最佳时机" aria-hidden="true">#</a> 买卖股票的最佳时机</h2><blockquote><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p></blockquote><blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><blockquote><p>思路:</p><p>动态规划题: 对于第N天来说最大利润为 N-1天的最大利润以及算上当天以后计算的利润值求max</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo stretchy="false">{</mo><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mtext>本天的利润</mtext><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>n</mi><mo>&gt;</mo><mn>1</mn></mrow><mrow><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>=</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">T(n) = \{ ^{ 0, n = 1 } _{ max( T(n-1) , 本天的利润 ) ,n &gt; 1 } \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4472em;vertical-align:-0.5152em;"></span><span class="mopen"><span class="mopen">{</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.932em;"><span style="top:-2.3598em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ma</span><span class="mord mathnormal mtight">x</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mpunct mtight">,</span><span class="mord cjk_fallback mtight">本天的利润</span><span class="mclose mtight">)</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">n</span><span class="mrel mtight">&gt;</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">n</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5152em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">maxProfit</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">prices</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
   <span class="token keyword">let</span> minPrice <span class="token operator">=</span> prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
   <span class="token comment">// To record current day profits.</span>
   <span class="token keyword">let</span> curProfit
   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prices<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      curProfit <span class="token operator">=</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> minPrice
      <span class="token comment">// No money can be earned when present-day profit is 0.</span>
      curProfit <span class="token operator">=</span> curProfit <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">?</span> curProfit <span class="token operator">:</span> <span class="token number">0</span>

      dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>curProfit<span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
      
      <span class="token comment">// Attempt to update the min price.</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> minPrice<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          minPrice <span class="token operator">=</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">return</span> dp<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="只出现一次的数字" tabindex="-1"><a class="header-anchor" href="#只出现一次的数字" aria-hidden="true">#</a> 只出现一次的数字</h2><blockquote><p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p></blockquote><blockquote><p><strong>示例 1 ：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入：nums = [2,2,1]
输出：1

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2 ：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入：nums = [4,1,2,1,2]
输出：4
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><blockquote><p>思路: 本题考察异或的知识, 忘记了自己百度下</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">singleNumber</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        num <span class="token operator">^=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> num
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="环形链表" tabindex="-1"><a class="header-anchor" href="#环形链表" aria-hidden="true">#</a> 环形链表</h2><blockquote><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：pos 不作为参数进行传递 **。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p></blockquote><p>**记录法 **</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>ListNode<span class="token punctuation">}</span></span> <span class="token parameter">head</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>boolean<span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">hasCycle</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> record <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>record<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span>
        record<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span>
        head <span class="token operator">=</span> head<span class="token punctuation">.</span>next
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>快慢指针法(龟兔赛跑法). 设置两根指针, 慢指针一次移动一步, 快指针一次移动两部. 假设有环, 快指针会追上慢指针, 假设无环, 快指针会先到null</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>ListNode<span class="token punctuation">}</span></span> <span class="token parameter">head</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>boolean<span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">hasCycle</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">let</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">let</span> fast <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>slow <span class="token operator">!=</span> fast<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>fast <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> fast<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="相交链表" tabindex="-1"><a class="header-anchor" href="#相交链表" aria-hidden="true">#</a> 相交链表</h2><blockquote><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p></blockquote><blockquote><p>思路: 先跑一遍任一链表, 只做存储, 再跑另一个链表, 只做查询. 查询的到返回节点, 查询不到返回null</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">getIntersectionNode</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">headA<span class="token punctuation">,</span> headB</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>headA <span class="token operator">||</span> <span class="token operator">!</span>headB<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span> <span class="token comment">// 如果有链表不存在, 没有相交点</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>headA <span class="token operator">===</span> headB<span class="token punctuation">)</span> <span class="token keyword">return</span> headA <span class="token comment">// 如果为同一条链表, 则第一个点是相交点</span>

    <span class="token keyword">const</span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> temp 
    temp <span class="token operator">=</span> headA
    <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">{</span>
        set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span>
        temp <span class="token operator">=</span> temp<span class="token punctuation">.</span>next
    <span class="token punctuation">}</span>
    temp <span class="token operator">=</span> headB
    <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> temp
        <span class="token punctuation">}</span>
        temp <span class="token operator">=</span> temp<span class="token punctuation">.</span>next
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token keyword">null</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="反转链表" tabindex="-1"><a class="header-anchor" href="#反转链表" aria-hidden="true">#</a> 反转链表</h2><blockquote><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p></blockquote><blockquote><p>要求: 使用 迭代法和 递归两种方法实现</p></blockquote><blockquote><p>思路: 迭代法很简单, 栈可以用作逆序的输出. 递归稍微复杂点, 主要分析好递归最后的状态, 和回归时候需要给下一个栈帧传递什么样的数据就可了</p></blockquote><p><strong>迭代法</strong></p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">reverseList</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">{</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span>
        head <span class="token operator">=</span> head<span class="token punctuation">.</span>next
    <span class="token punctuation">}</span>

    <span class="token keyword">let</span> newHead <span class="token operator">=</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        temp<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        temp <span class="token operator">=</span> temp<span class="token punctuation">.</span>next
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> newHead<span class="token punctuation">.</span>next
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>递归</strong></p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">reverseList</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span>
    <span class="token keyword">let</span> h <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">const</span> <span class="token function-variable function">compositeLinkedList</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">{</span>
           <span class="token keyword">const</span> preNode <span class="token operator">=</span> <span class="token function">compositeLinkedList</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>next<span class="token punctuation">)</span>
           preNode<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode
           
        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
          h <span class="token operator">=</span> newNode
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> newNode 
    <span class="token punctuation">}</span>
    <span class="token function">compositeLinkedList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span>
    <span class="token keyword">return</span> h
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="回文链表" tabindex="-1"><a class="header-anchor" href="#回文链表" aria-hidden="true">#</a> 回文链表</h2><blockquote><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p></blockquote><blockquote><p><strong>示例 1：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入：head = [1,2,2,1]
输出：true
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><blockquote><p>思路:</p><p>最简单的是双指针: 链表 --&gt; 数组 --&gt; 头尾同时向中移动, 边移动边比较. 双指针不再写了, 写一下递归和快慢指针法</p></blockquote><p><strong>递归法</strong></p><blockquote><p>递归可以拿到链表最后一个节点到第一个节点的每个顺序, 然后外部变量head可以拿到从head到最后的每个节点, 利用这个特性设计出递归函数</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">head</span><span class="token operator">:</span> ListNode <span class="token operator">|</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span><span class="token operator">:</span> boolean <span class="token punctuation">{</span>

    <span class="token keyword">const</span> <span class="token function-variable function">dfs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">node</span><span class="token operator">:</span>ListNode</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token comment">// Save the result of the previous comparison. </span>
        <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token boolean">true</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">{</span>
            result <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>next<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        
        <span class="token comment">// Return true if both the previous comparison and the current comparison were successful. </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>result <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>val <span class="token operator">===</span> head<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next
            <span class="token keyword">return</span> <span class="token boolean">true</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> <span class="token boolean">false</span> 
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> head <span class="token operator">?</span>  <span class="token function">dfs</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>快慢指针</strong></p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">isPalindrome</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>
  
  <span class="token keyword">let</span> fast <span class="token operator">=</span> slow <span class="token operator">=</span> node
  
  <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">{</span>
    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next
    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next
  <span class="token punctuation">}</span>
  
  <span class="token keyword">let</span> cur <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>slow<span class="token punctuation">)</span>
  
  <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val <span class="token operator">!==</span> node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
    cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next
    node <span class="token operator">=</span> node<span class="token punctuation">.</span>next
  <span class="token punctuation">}</span>
  
  <span class="token keyword">return</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>总结:</p><p>主要总结快慢指针的作用</p><ol><li>可以寻找链表中的特定节点. 比如中点, 1/3的点, 1/4的点. 具体操作就是让快指针移动的速度是慢指针的n倍, 快指针遍历完后, 慢指针就是要寻找的点</li><li>可以判断链表的奇偶. 指针步长为2. 若链表节点数为偶, 则指针遍历完后为null. 若链表为奇数, 则指针遍历完后为节点</li><li>快慢指针的循环条件一般为 while(fast &amp;&amp; fast.next) .没有节点不走, 只有一个节点也不走.</li></ol></blockquote><h2 id="移动零" tabindex="-1"><a class="header-anchor" href="#移动零" aria-hidden="true">#</a> 移动零</h2><blockquote><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p></blockquote><blockquote><p>思考:可以借用快排的小于等于区法, 还可以使用冒泡排序的思想</p></blockquote><p><strong>小于等于区双指针法</strong></p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">moveZeroes</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 借用快速排序的思想</span>
   <span class="token comment">// 将数组看成非零区和零区</span>
   <span class="token comment">// 设置一个指针, 默认负一, 用于划定非零区, 如果是零, 跳过遍历, 如果非零, 放到非零区最前一位, 非零区+1</span>

   <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>
   <span class="token keyword">let</span> temp
   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span>
        temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span>
        nums<span class="token punctuation">[</span>p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp
        p<span class="token operator">++</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>冒泡排序法</strong></p><blockquote><p>将0视为目标元素, 实现冒泡的过程. 此算法不改变相对位置</p><p>不能使用选择排序, 因为选择排序是不稳定排序, 冒泡排序是稳定排序</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token literal-property property">实现</span><span class="token operator">:</span> 略
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="比特位计数" tabindex="-1"><a class="header-anchor" href="#比特位计数" aria-hidden="true">#</a> 比特位计数</h2><blockquote><p>给你一个整数 <code>n</code> ，对于 <code>0 &lt;= i &lt;= n</code> 中的每个 <code>i</code> ，计算其二进制表示中 <strong>1 的个数</strong> ，返回一个长度为 <code>n + 1</code> 的数组 <code>ans</code> 作为答案。</p></blockquote><blockquote><p><strong>示例 1：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入：n = 2
输出：[0,1,1]
解释：
0 --&gt; 0
1 --&gt; 1
2 --&gt; 10
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><blockquote><p>思考: 我使用了内置Api: number.toString(2), 这一题实际在考察位运算, 所以这个解不算优解, 先放一放, 位运算的题放到刷题后期做.</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">countBits</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">const</span> bChar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> bChar<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>bChar<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                count<span class="token operator">++</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        ans<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> ans
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="找到所有数组中消失的数字" tabindex="-1"><a class="header-anchor" href="#找到所有数组中消失的数字" aria-hidden="true">#</a> 找到所有数组中消失的数字</h2><blockquote><p>给你一个含 <code>n</code> 个整数的数组 <code>nums</code> ，其中 <code>nums[i]</code> 在区间 <code>[1, n]</code> 内。请你找出所有在 <code>[1, n]</code> 范围内但没有出现在 <code>nums</code> 中的数字，并以数组的形式返回结果。</p></blockquote><blockquote><p><strong>示例 1：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入：nums = [4,3,2,7,8,2,3,1]
输出：[5,6]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p><strong>方法一: 记录法</strong></p><blockquote><p>思路:</p><ol><li>用一个数组记录[1,n]范围内, 每个数字出现的次数. 其中下标代表数字, 值代表次数</li><li>遍历nums, 统计出个数字出现次数</li><li>遍历记录数组, 将出现次数为0的数字挑出来到result结果数组</li></ol></blockquote><blockquote><p>空间复杂度O(n) 时间复杂度O(n)</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">findDisappearedNumbers</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> record <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>
           record<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> record<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>record<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
           result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

    <span class="token keyword">return</span> result
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法二: 直接修改法(leetcode官方题解)</strong></p><blockquote><p>思路:</p><ol><li>操作建立在直接修改原数组的基础上</li><li>原数组的下标代表[1-n]的数字, 值如果是 &gt; n的代表出现过, &lt;n的代表未出现过</li><li>遍历原数组, 取出数字, 找出对应的下标, 将对应下标的数字 + n .</li><li>遍历原数组, 如果 &gt; n则出现过, 反之未出现过, 加入result</li><li>注意: 比如 [2,1] 长度为2的数组, 当遍历到 2 时候, 会将下标为1的数字 + 2, 数组变为[2,3], 这样继续遍历到 3时候, 我们本来想的是将下标为0的数字+n, 但是现在数字是3, 拿不到原始下标, 需要 % length 才行</li></ol></blockquote><blockquote><p>时间复杂度(On), 在不考虑结果数组所占的空间result时, 空间复杂度为O(1)</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">findDisappearedNumbers</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length
  <span class="token keyword">for</span><span class="token punctuation">(</span>num <span class="token keyword">of</span> nums<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> idx <span class="token operator">=</span> num <span class="token operator">%</span> n <span class="token operator">-</span> <span class="token number">1</span>  <span class="token comment">// 数字-1, 即数字对应的索引位置. 取余是因为可能被+n过, 还原树子</span>
    nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">+=</span> n
  <span class="token punctuation">}</span>
  
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token punctuation">[</span>index<span class="token punctuation">,</span>num<span class="token punctuation">]</span> <span class="token keyword">of</span> nums<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>num <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>总结:</p><p>方法一是我自己写的, 方法二是官方题解</p><p>我自己和官方差在在哪呢? 有哪些是好的, 哪些是需要精进的?</p><p>好的地方是: 和官方都用了数组表示记录, 数组下标表示数字, 值表示出现的状态</p><p>精进的地方比较多:</p><ol><li>没有意识到原地修改数组. 当然这在开发中并不一定是坏事, 只是对于这种追求空间的算法, 要有这个意识</li><li>表示数字出现的状态我用的是 &quot;数字出现的次数&quot; 官方用的是 &quot;大于n的表示未出现过, 小于n的代表出现过&quot;. 我的想法明显非常符合常识, 但巧妙性上远不如官方</li><li>对取余的作用需要再巩固一下 <ol><li>基数排序中的取余操作, 取出一个数的个位数 number % 10</li><li>(A + B) % B = A</li><li>当A &lt;= B时, A % B = A</li></ol></li></ol></blockquote><h2 id="二叉树的直径" tabindex="-1"><a class="header-anchor" href="#二叉树的直径" aria-hidden="true">#</a> 二叉树的直径</h2><blockquote><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p></blockquote><blockquote><p><strong>示例 :</strong> 给定二叉树</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>          1
         / \
        2   3
       / \     
      4   5    

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><p>**注意：**两结点之间的路径长度是以它们之间边的数目表示。</p></blockquote><blockquote><p>思路:</p><p>/**</p><p>​ 假设以X节点出发, 可以向左右子树要信息</p><p>​ 则需要:</p><p>​ 1. 如果路径穿过X节点</p><p>​ - 左子树的深度(</p><p>​ - 右子树的深度</p><p>​ - 直径 = 左子树深度 + 右子树的深度</p><p>​ 2. 如果路径不穿过X节点</p><p>​ - 左子树最大边数</p><p>​ - 右子树最大边数</p><p>​ - 直径 = Max(左边数,右边数)</p><p>​ 直径 = max(穿过可能性的直径, 不穿过可能性的直径)</p><p>​ */</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">diameterOfBinaryTree</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token function-variable function">dfs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span>
            <span class="token literal-property property">height</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span>
            <span class="token literal-property property">maxBridges</span><span class="token operator">:</span><span class="token number">0</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">const</span> leftInfo <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        <span class="token keyword">const</span> rightInfo <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>

        <span class="token keyword">const</span> height <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftInfo<span class="token punctuation">.</span>height<span class="token punctuation">,</span> rightInfo<span class="token punctuation">.</span>height<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token keyword">const</span> maxBridges <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>
            leftInfo<span class="token punctuation">.</span>height <span class="token operator">+</span> rightInfo<span class="token punctuation">.</span>height <span class="token punctuation">,</span> <span class="token comment">// 经过X节点的最大路径</span>
            Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftInfo<span class="token punctuation">.</span>maxBridges<span class="token punctuation">,</span> rightInfo<span class="token punctuation">.</span>maxBridges<span class="token punctuation">)</span> <span class="token comment">// 不经过X节点的最大路径</span>
        <span class="token punctuation">)</span>

        <span class="token keyword">return</span> <span class="token punctuation">{</span>
            height<span class="token punctuation">,</span>
            maxBridges
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>


    <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">.</span>maxBridges

<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="合并二叉树" tabindex="-1"><a class="header-anchor" href="#合并二叉树" aria-hidden="true">#</a> 合并二叉树</h2><blockquote><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p></blockquote><blockquote><p><strong>示例 1：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
输出：[3,4,5,5,4,null,7]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><blockquote><p><strong>示例 2：</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入：root1 = [1], root2 = [1,2]
输出：[2,2]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p><strong>修改原树的方法</strong></p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">mergeTrees</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root1<span class="token punctuation">,</span> root2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">const</span> <span class="token function-variable function">dfs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root1<span class="token punctuation">,</span>root2<span class="token punctuation">,</span>parent<span class="token punctuation">,</span>isLeft</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root1<span class="token punctuation">)</span> <span class="token keyword">return</span> 
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root2 <span class="token punctuation">)</span><span class="token punctuation">{</span>
            isLeft <span class="token operator">?</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> root1<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> root1<span class="token punctuation">)</span>
            <span class="token keyword">return</span> 
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root1 <span class="token operator">&amp;&amp;</span> root2<span class="token punctuation">)</span><span class="token punctuation">{</span>
            root2<span class="token punctuation">.</span>val <span class="token operator">+=</span> root1<span class="token punctuation">.</span>val
        <span class="token punctuation">}</span>

        <span class="token function">dfs</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root2<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root2<span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>right<span class="token punctuation">,</span>root2<span class="token punctuation">.</span>right<span class="token punctuation">,</span>root2<span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root2<span class="token punctuation">)</span> <span class="token keyword">return</span> root1
     <span class="token function">dfs</span><span class="token punctuation">(</span>root1<span class="token punctuation">,</span>root2<span class="token punctuation">,</span>root2<span class="token punctuation">)</span>
    <span class="token keyword">return</span> root2
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>不修改原树的方法</strong></p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">mergeTrees</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">t1<span class="token punctuation">,</span> t2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>t1 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> t2<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> t1<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> merged <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span>val <span class="token operator">+</span> t2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    merged<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    merged<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> merged<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="回溯-子集" tabindex="-1"><a class="header-anchor" href="#回溯-子集" aria-hidden="true">#</a> 回溯 -- 子集</h2><blockquote><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p></blockquote><blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><blockquote><p>思考:</p><p>思路一: 动态规划, 默认空集是子集, 任何元素和空集相交, 都是本身</p><p>那么从头遍历到尾, 每拿到一个数字, 和之前所有的集合相交得到新的子集</p></blockquote><blockquote><p>思路二: 回溯法.</p><p>策略是 : 每一个数字都可以和未访问过的数字组成子集</p><p>那么使用回溯, 从第一个数字触发, 遍历剩余数字, 记录回溯的路线, 路线上没每更新一个路径就更新下结果集. 到最后一个节点则取消路径回溯</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span> <span class="token parameter">nums</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">subsets</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
   <span class="token keyword">const</span> <span class="token function-variable function">backtrack</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> track <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
       res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>track<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

       <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> index<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
           track<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
           <span class="token function">backtrack</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> track<span class="token punctuation">)</span>
           track<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
   <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token keyword">return</span> res
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="回溯-全排列" tabindex="-1"><a class="header-anchor" href="#回溯-全排列" aria-hidden="true">#</a> 回溯 -- 全排列</h2><blockquote><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p></blockquote><blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入：nums = [0,1]
输出：[[0,1],[1,0]]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><blockquote><p>思路:</p><p>一开始我的思路是错的. 但是也比较有意思, 所以记录一下</p><p>我将数组[1,2,3]想象成环, 1的全排列为从1开始, 向右跑到1的所有数组的集合以及向左跑到1所有数组的集合</p><p>但是这种思路值通过了[1,2,3]一个测试用例.</p><p>根本原因是, 对题意的理解不到位. 假如[1,2,3,4]为测试用例. 那么根据我的思路得出的结果为</p><p>从 1 --&gt; 向右跑回1的组合和从 1向左跑回1的组合 即 [1,2,3,4] 和 [1,4,3,2]很明显缺少了很多比如[1,3,2,4], [1,4,2,3], 所以这种方法是不对的..</p></blockquote><blockquote><p>下面是错误的代码</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span> <span class="token parameter">nums</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">permute</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span>nums<span class="token punctuation">]</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token keyword">const</span> ret <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">let</span> num<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">,</span>temp
    
    <span class="token keyword">const</span> <span class="token function-variable function">getLeft</span> <span class="token operator">=</span> <span class="token parameter">l</span> <span class="token operator">=&gt;</span> l <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">:</span> l <span class="token operator">-</span> <span class="token number">1</span>
    <span class="token keyword">const</span> <span class="token function-variable function">getRight</span> <span class="token operator">=</span> <span class="token parameter">r</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> nums<span class="token punctuation">.</span>length

    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        num <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        left <span class="token operator">=</span> <span class="token function">getLeft</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token comment">// 如果越左边界, 从最右边开始</span>
        right <span class="token operator">=</span> <span class="token function">getRight</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token comment">// 如果越右边界, 从0开始</span>
        
        temp <span class="token operator">=</span> <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">!==</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>
            temp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>
            right <span class="token operator">=</span> <span class="token function">getRight</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        ret<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span>

        temp <span class="token operator">=</span> <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">!==</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>
            temp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span>
            left <span class="token operator">=</span> <span class="token function">getLeft</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        ret<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span>

       
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> ret
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>正确的思路:</p><p>排列组合的问题往往是暴力枚举, 可以使用回溯法</p><ol><li>首先划出多叉树, 以[1,2,3]为例, 可以画出一个无限深度的三叉树</li><li>思考三叉树的深度. 每一层代表一次探索, 即全排列一个解的一个数字. 最深应该为nums.length</li><li>思考剪枝的策略: 每一层不能出现探索过的踪迹</li><li>思考递归出口, 边缘case. 每次添加一个数字, 探索到跟数组长度相同的时候, 此时track数组中刚好nums.length个元素, 此时做添加操作</li><li>套用回溯模板</li></ol></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">permute</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> ret <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">const</span> <span class="token function-variable function">backtrack</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">track <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">===</span> track<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>
           <span class="token keyword">return</span> ret<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>track<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>track<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">continue</span>
            <span class="token punctuation">}</span>

            track<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token function">backtrack</span><span class="token punctuation">(</span>track<span class="token punctuation">)</span>
            track<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
    <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> ret 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="回溯-括号生成" tabindex="-1"><a class="header-anchor" href="#回溯-括号生成" aria-hidden="true">#</a> 回溯 -- 括号生成</h2><blockquote><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的 **括号组合。</p></blockquote><blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入：n = 3
输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入：n = 1
输出：[&quot;()&quot;]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><blockquote><p>思路:</p><ol><li>先画图. 每次有( )两种选择, 设每层选择一个括号, 则可以画出一个无限深度的满二叉树</li><li>定深度. n是括号的对数, 假如一层选择一个括号, 则可以画出一棵深度为2n的满二叉树</li><li>剪枝. <ul><li>第一次剪枝 : 可以发现 当以 &quot;)&quot;开始时候, 所有的括号都不符合规则. 所以当第一层时候, 不用递归 )的情况</li><li>第二次剪枝: 可以记录左右括号的数量. 如果数量超过n, 则证明一定不是有效的括号, 则不用递归</li><li>第三次剪枝: 当递归的过程中, 右括号的个数大于左括号的个数时候, 则证明一定不是有效的括号.,不用继续递归</li><li>我的代码, 只剪枝到第二次. 剪枝依靠经验和机灵,做题的时候, 不一定一下子剪枝到最优解, 想到哪减到哪, 多积累经验</li></ul></li><li>思考边缘case, 递归出口</li></ol></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">generateParenthesis</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> ret <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

    <span class="token keyword">const</span> backtrack <span class="token operator">=</span> <span class="token punctuation">(</span>leftCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>rightCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>track <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>leftCount <span class="token operator">===</span> rightCount <span class="token operator">&amp;&amp;</span> rightCount <span class="token operator">===</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isValid</span><span class="token punctuation">(</span>track<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
              ret<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>track<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">return</span>
      <span class="token punctuation">}</span>

      <span class="token keyword">if</span><span class="token punctuation">(</span>leftCount <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token function">backtrack</span><span class="token punctuation">(</span>leftCount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> rightCount<span class="token punctuation">,</span> track <span class="token operator">+=</span> <span class="token string">&quot;(&quot;</span><span class="token punctuation">)</span>
          track <span class="token operator">=</span> track<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> track<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>rightCount <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> leftCount <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
           <span class="token function">backtrack</span><span class="token punctuation">(</span>leftCount<span class="token punctuation">,</span> rightCount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> track <span class="token operator">+=</span> <span class="token string">&quot;)&quot;</span><span class="token punctuation">)</span>
           track <span class="token operator">=</span> track<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> track<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">const</span> <span class="token function-variable function">isValid</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">parentheses</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>parenthesis<span class="token punctuation">;</span> parenthesis <span class="token operator">=</span> parentheses<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>parenthesis <span class="token operator">===</span> <span class="token string">&#39;(&#39;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>parenthesis<span class="token punctuation">)</span>
                <span class="token keyword">continue</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 如果遍历的为右括号, 栈里的不是左括号, 则不是有效的括号</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token string">&#39;(&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> stack<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
    <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> ret
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="分治-从前序与中序遍历序列构造二叉树" tabindex="-1"><a class="header-anchor" href="#分治-从前序与中序遍历序列构造二叉树" aria-hidden="true">#</a> 分治 -- 从前序与中序遍历序列构造二叉树</h2><blockquote><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p></blockquote><blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p><strong>版本一</strong></p><blockquote><p>思路:</p><p>构建二叉树的过程分为三步:</p><ol><li>构建根节点</li><li>构建左子树</li><li>构建右子树</li></ol><p>而构建左/右子树的过程也是如上三步, 即明显为递归.</p><p>关键思路: 从preorder中拿到树的根节点, 再去inorder中拿到树的左子树的信息. 根据左子树的信息可以推断出右子树的信息</p><p>也可以从preorder中拿到树的的根节点, 再去inorder中拿到树的右子树的信息, 根据右子树可以推断出左子树的信息</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">buildTree</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">preorder<span class="token punctuation">,</span> inorder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>preorder<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">||</span> inorder<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
     <span class="token keyword">const</span> parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
     <span class="token keyword">const</span> inRootIdx <span class="token operator">=</span> inorder<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
     parent<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>preorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> inRootIdx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>inorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> inRootIdx<span class="token punctuation">)</span><span class="token punctuation">)</span>
     parent<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>preorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>inRootIdx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preorder<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">,</span>inorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>inRootIdx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inorder<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span>
     <span class="token keyword">return</span> parent
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>版本二: 优化数组</strong></p><blockquote><p>上面代码中</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code> parent<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>preorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> inRootIdx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>inorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> inRootIdx<span class="token punctuation">)</span><span class="token punctuation">)</span>
 parent<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>preorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>inRootIdx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preorder<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">,</span>inorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>inRootIdx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inorder<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>生成了左子树的前中序数组, 和右子树的前中序数组. 每次递归都会创建四个数组. 其实并不必要</p><p>对于左右子树的前中序数组, 都是原树前中序数组的子集. 只需要分别用两对指针划定左右子树的范围即可, 不用创建新数组</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">buildTree</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">preorder<span class="token punctuation">,</span> inorder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token function-variable function">helper</span> <span class="token operator">=</span> <span class="token punctuation">(</span>
        <span class="token parameter">preLeft <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> preRight <span class="token operator">=</span> preorder<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>
        inLeft <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> inRight <span class="token operator">=</span> inorder<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span></span>
    <span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 用两对指针表示前序, 中序数组的范围</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>preLeft <span class="token operator">&gt;</span> preRight <span class="token operator">||</span> inLeft <span class="token operator">&gt;</span> inRight<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">const</span> parentVal <span class="token operator">=</span> preorder<span class="token punctuation">[</span>preLeft<span class="token punctuation">]</span>
        <span class="token keyword">const</span> parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>parentVal<span class="token punctuation">)</span>
        <span class="token keyword">const</span> inRootIdx <span class="token operator">=</span> inorder<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>parentVal<span class="token punctuation">)</span> <span class="token comment">// 中序遍历时候, 根节点的索引值</span>
        <span class="token keyword">const</span> preLeftTreePivot <span class="token operator">=</span> inRootIdx <span class="token operator">-</span> inLeft <span class="token operator">+</span> preLeft   <span class="token comment">// 前序遍历时候, 左子树的右边界的索引值</span>
        parent<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>preLeft <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preLeftTreePivot <span class="token punctuation">,</span> inLeft<span class="token punctuation">,</span> inRootIdx <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
        parent<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>preLeftTreePivot <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preRight<span class="token punctuation">,</span> inRootIdx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inRight<span class="token punctuation">)</span>

        <span class="token keyword">return</span> parent
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>版本三: 优化查询</strong></p><blockquote><p>const inRootIdx = inorder.indexOf(parentVal)</p><p>每一次递归的时候都要线性的找父节点, O(n)的查询效率.</p><p>那么可以在一开始的时候, 将所有的值--&gt; 索引的关系存在Hash表中, 查询效率变成O(1)</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>ar <span class="token function-variable function">buildTree</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">preorder<span class="token punctuation">,</span> inorder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    inorder<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span>idx</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 这部能实行依靠于题解声明, value不重复</span>

    <span class="token keyword">const</span> <span class="token function-variable function">helper</span> <span class="token operator">=</span> <span class="token punctuation">(</span>
        <span class="token parameter">preLeft <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> preRight <span class="token operator">=</span> preorder<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>
        inLeft <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> inRight <span class="token operator">=</span> inorder<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span></span>
    <span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>preLeft <span class="token operator">&gt;</span> preRight <span class="token operator">||</span> inLeft <span class="token operator">&gt;</span> inRight<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">const</span> parentVal <span class="token operator">=</span> preorder<span class="token punctuation">[</span>preLeft<span class="token punctuation">]</span>
        <span class="token keyword">const</span> parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>parentVal<span class="token punctuation">)</span>
        <span class="token keyword">const</span> inRootIdx <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>parentVal<span class="token punctuation">)</span> <span class="token comment">// 小改动大进步...</span>
        <span class="token keyword">const</span> preLeftTreePivot <span class="token operator">=</span> inRootIdx <span class="token operator">-</span> inLeft <span class="token operator">+</span> preLeft  
        parent<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>preLeft <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preLeftTreePivot <span class="token punctuation">,</span> inLeft<span class="token punctuation">,</span> inRootIdx <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
        parent<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>preLeftTreePivot <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preRight<span class="token punctuation">,</span> inRootIdx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inRight<span class="token punctuation">)</span>

        <span class="token keyword">return</span> parent
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="分治-从后序与中序遍历序列构造二叉树" tabindex="-1"><a class="header-anchor" href="#分治-从后序与中序遍历序列构造二叉树" aria-hidden="true">#</a> 分治 -- 从后序与中序遍历序列构造二叉树</h2><blockquote><p>与上道题不能说完全一致, 只能说一模一样.</p><p>作为练习贴一下解答</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">buildTree</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">inorder<span class="token punctuation">,</span> postorder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    inorder<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span>idx</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">const</span> <span class="token function-variable function">helper</span> <span class="token operator">=</span> <span class="token punctuation">(</span>
        <span class="token parameter">pLeft <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> pRight <span class="token operator">=</span> postorder<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>
        iLeft <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>iRight <span class="token operator">=</span> inorder<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span></span>
    <span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>pLeft <span class="token operator">&gt;</span> pRight <span class="token operator">||</span> iLeft <span class="token operator">&gt;</span> iRight<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">const</span> rootVal <span class="token operator">=</span> postorder<span class="token punctuation">[</span>pRight<span class="token punctuation">]</span>
        <span class="token keyword">const</span> inRootPivot <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span>

        <span class="token keyword">const</span> parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span>
        parent<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>pLeft<span class="token punctuation">,</span> pRight <span class="token operator">-</span> iRight <span class="token operator">+</span> inRootPivot <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> iLeft<span class="token punctuation">,</span> inRootPivot <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
        parent<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>pRight <span class="token operator">-</span> iRight <span class="token operator">+</span> inRootPivot<span class="token punctuation">,</span> pRight <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> inRootPivot <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>iRight<span class="token punctuation">)</span>
        <span class="token keyword">return</span> parent
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="分治-数组中的第k个最大元素" tabindex="-1"><a class="header-anchor" href="#分治-数组中的第k个最大元素" aria-hidden="true">#</a> 分治 -- 数组中的第K个最大元素</h2><blockquote><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p></blockquote><blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入: [3,2,1,5,6,4], k = 2
输出: 5
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><blockquote><p>思路: 题目就是想让实现下快排</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">findKthLargest</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">nums<span class="token punctuation">,</span> k</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token function-variable function">patition</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">nums<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> pivot <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>

        <span class="token keyword">while</span><span class="token punctuation">(</span>right <span class="token operator">&gt;</span> left<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>right <span class="token operator">&gt;</span> left <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">)</span><span class="token punctuation">{</span>
                right<span class="token operator">--</span>
            <span class="token punctuation">}</span>
            nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span>
            
            <span class="token keyword">while</span><span class="token punctuation">(</span>right <span class="token operator">&gt;</span> left <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&gt;</span> pivot<span class="token punctuation">)</span><span class="token punctuation">{</span>
                left<span class="token operator">++</span>
            <span class="token punctuation">}</span>
            nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
        nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> pivot
        <span class="token keyword">return</span> left 
    <span class="token punctuation">}</span>

    <span class="token keyword">const</span> <span class="token function-variable function">quickSort</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>right <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&gt;</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> 
        <span class="token keyword">const</span> mid <span class="token operator">=</span> <span class="token function">patition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span>
        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
    <span class="token keyword">return</span> nums<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">findKthLargest</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="贪心-盛最多水的容器" tabindex="-1"><a class="header-anchor" href="#贪心-盛最多水的容器" aria-hidden="true">#</a> 贪心 -- 盛最多水的容器</h2><blockquote><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>**说明：**你不能倾斜容器。</p></blockquote><p><strong>暴力解法</strong></p><blockquote><p>第一重循环枚举左边的线, 第二重循环枚举右边的线. 这样就能拿到每种组合的面积, 每次尝试更新max面积</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">maxArea</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">height</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token function-variable function">getWater</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">x1<span class="token punctuation">,</span>x2</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>x2 <span class="token operator">-</span> x1<span class="token punctuation">)</span> <span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>x1<span class="token punctuation">]</span><span class="token punctuation">,</span>height<span class="token punctuation">[</span>x2<span class="token punctuation">]</span><span class="token punctuation">)</span>

    <span class="token keyword">const</span> x <span class="token operator">=</span> height<span class="token punctuation">.</span>length
    <span class="token keyword">let</span> max <span class="token operator">=</span> <span class="token number">0</span> 
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> x<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> x<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span><span class="token function">getWater</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> max
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>贪心算法 + 双指针</strong></p><blockquote><p>由题意可得 $ S(left,right) = (right - left) * Min(h[right], h[left]) $</p><p>假设, left初始值设置为0, right初始值设为 n - 1</p><p>则无论怎么移动 right - left都在变小, 即 S(left, right)在变小</p><p>假设 1. 移动短的边, 则原本的短边可能变成长边, Min(h[right], h[left]), 是有可能变大的也就是说S(left,right)可能变大</p><p>假设 2. 移动长的边, 则 Min(h[right], h[left]) 一定变小或者不变, 也就是所S(left,right)可能不变或者变小</p><p>综上</p><p>策略即为, 使用双指针分别指针指向头尾, 此时宽度最大. 然后分别移动左右指针中短的那跟, 期许每一步的移动使S(left,right)可能变大</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">maxArea</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">height</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token function-variable function">getWater</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span>right</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>

    <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token number">0</span>
      <span class="token punctuation">,</span> right <span class="token operator">=</span> height<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>
      <span class="token punctuation">,</span> max <span class="token operator">=</span> <span class="token number">0</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> <span class="token function">getWater</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            left<span class="token operator">++</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            right<span class="token operator">--</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> max
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="贪心-跳跃游戏" tabindex="-1"><a class="header-anchor" href="#贪心-跳跃游戏" aria-hidden="true">#</a> 贪心 -- 跳跃游戏</h2><blockquote><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p></blockquote><blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p><strong>暴力求解</strong></p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">canJump</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> end <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>
    <span class="token keyword">let</span> flag <span class="token operator">=</span> <span class="token boolean">false</span>

    <span class="token keyword">const</span> <span class="token function-variable function">helper</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">position <span class="token operator">=</span> <span class="token number">0</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>position <span class="token operator">===</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>
            flag <span class="token operator">=</span> <span class="token boolean">true</span>
            <span class="token keyword">return</span> 
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>position <span class="token operator">&gt;</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> 
        <span class="token punctuation">}</span>

        <span class="token keyword">const</span> steps <span class="token operator">=</span> nums<span class="token punctuation">[</span>position<span class="token punctuation">]</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> steps<span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">helper</span><span class="token punctuation">(</span>position <span class="token operator">+</span> i<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
    <span class="token function">helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> flag 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>贪心算法</strong></p><blockquote><p>用变量k记录, 最大的到达的位置. 在遍历中更新最大能到达的位置, 如果当前位置比最大的位置还要大则证明当前位置不能到达, 则return false. 遍历完了则返回true</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">canJump</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">let</span> k <span class="token operator">=</span> <span class="token number">0</span>
   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&gt;</span> k<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>
       k <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> i <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">return</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><!--]--></div><!----><footer class="page-meta"><!----><!----><!----></footer><nav class="page-nav"><a href="/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html" class="nav-link prev" aria-label="数据结构与算法"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><i class="icon iconfont icon-edit"></i>数据结构与算法</div></a><!----></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer"></div><div class="copyright">Copyright © 2023 苏察哈尔灿</div></footer><!--]--></div><!--]--><!----><!----><!--]--></div>
    <script type="module" src="/assets/app.ebc51866.js" defer></script>
  </body>
</html>
